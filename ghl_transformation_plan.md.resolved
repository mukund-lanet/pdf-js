# GoHighLevel Pattern Transformation Plan

## Executive Summary

Transform the current PDF editor workflow from a **buffer-based** approach to GoHighLevel's **page-centric Firebase image** architecture.

---

## Current Workflow (OLD)

### Data Structure
```typescript
{
  pdfBytes: Uint8Array,          // PDF buffer from pdf-lib
  totalPages: number,
  currentPage: number,
  canvasElements: CanvasElement[], // Flat array with page references
  pageDimensions: { [pageNum]: { width, height } }
}
```

### Element Storage
- **Blocks**: `['heading', 'image', 'video', 'table']` with `order` property
- **Fillables**: `['text-field', 'signature', 'date', 'initials', 'checkbox']` with `x, y` position
- All elements stored in **flat array** with `page:number` property

### Problems
1. PDF buffer required for rendering
2. No direct page-to-elements relationship
3. Difficult page reordering
4. Can't easily add blank pages
5. All elements in single array (not organized by page)

---

## GoHighLevel Workflow (NEW)

### Data Structure
```typescript
{
  pages: Page[],                 // Array of page objects
  variables: Variable[],
  fillableFields: FillableField[], // Global fillable fields registry
  fontsToLoad: string[]
}
```

### Page Structure
```typescript
interface Page {
  type: "Page",
  version: number,
  id: string,
  children: (BlockElement | FillableElement)[],  // Elements IN this page
  component: {
    name: "Page",
    options: {
      src: string,                    // Firebase image URL or empty for blank
      pageDimensions: {
        dimensions: { width, height },
        margins: { top, right, bottom, left },
        rotation: "portrait" | "landscape"
      }
    }
  },
  responsiveStyles: {
    large: {
      backgroundColor: string,
      backgroundPosition: string,
      backgroundSize: string,
      backgroundRepeat: string,
      opacity: number
    }
  }
}
```

### Element Structure (Children)
```typescript
// Block Element (Text, Image, Video, Table, ProductList)
{
  type: "Text" | "Image" | "Video" | "Table" | "ProductList",
  version: number,
  id: string,
  children: [],
  component: {
    name: string,
    options: { ... }  // Element-specific options
  },
  responsiveStyles: {
    large: {
      position: { top, left, bottom },  // Position from page top
      scale: { scaleX, scaleY },
      padding/margin: { ... },
      ... // Other styling
    }
  }
}

// Fillable Element (Signature, TextField, DateField, InitialsField)
{
  type: "Signature" | "TextField" | "DateField" | "InitialsField" | "Checkbox",
  version: number,
  id: string,
  children: [],
  component: {
    isDraggable: true,
    name: string,
    options: {
      isGhost: true,
      required: boolean,
      fieldId: string,
      recipient: string,
     entityName: string,
      ... // Field-specific options
    }
  },
  responsiveStyles: {
    large: {
      position: { top, left, bottom, right, width, height, preferBottom, preferRight },
      dimensions: { width, height },
      scale: { scaleX, scaleY },
      padding: { ... }
    }
  }
}
```

### Key Differences

| Aspect | Old Workflow | GoHighLevel |
|--------|-------------|-------------|
| **Pages** | Single pdfBytes | Array of page objects with Firebase URLs |
| **Elements** | Flat array with page prop | Nested in page.children |
| **Blank Pages** | Not supported | src = "" (blank div) |
| **PDF Pages** | Buffer-based | src = Firebase image URL |
| **Position** | x, y (absolute) | top, left (from page top) |
| **Blocks** | order property | Position-based in children array |
| **Structure** | Document-level | Page-level hierarchy |

---

## Transformation Strategy

### Phase 1: Update Type Definitions

#### New Page Interface
```typescript
interface PageComponent {
  name: "Page";
  options: {
    src: string;  // Firebase URL or "" for blank
    pageDimensions: {
      dimensions: { width: number; height: number };
      margins: { top: number; right: number; bottom: number; left: number };
      rotation: "portrait" | "landscape";
    };
  };
}

interface PageStyles {
  backgroundColor: string;
  backgroundPosition: string;
  backgroundSize: string;
  backgroundRepeat: string;
  opacity: number;
}

interface Page {
  type: "Page";
  version: number;
  id: string;
  children: (BlockElement | FillableElement)[];
  component: PageComponent;
  responsiveStyles: {
    large: PageStyles;
  };
}
```

#### Updated Element Interfaces
```typescript
// Base component for all elements
interface ElementComponent {
  name: string;
  isDraggable?: boolean;  // For fillable elements
  options: Record<string, any>;
}

interface ResponsiveStyles {
  large: {
    position?: {
      top: number;
      left: number;
      bottom?: number;
      right?: number;
      width?: number;
      height?: number;
      preferBottom?: boolean;
      preferRight?: boolean;
    };
    dimensions?: { width: number; height: number };
    scale?: { scaleX: number; scaleY: number };
    padding?: { top: string; right: string; bottom: string; left: string };
    margin?: { top: string | null; right: string | null; bottom: string | null; left: string | null };
    backgroundColor?: string;
    // ... other styling
  };
}

interface BaseElement {
  type: string;
  version: number;
  id: string;
  children: [];
  component: ElementComponent;
  responsiveStyles: ResponsiveStyles;
}

// Block elements extend BaseElement
interface HeadingElement extends BaseElement {
  type: "Text";
  component: {
    name: "Text Element";
    options: {
      text: string;  // HTML content
    };
  };
}

interface ImageElement extends BaseElement {
  type: "Image";
  component: {
    name: "Image Element";
    options: {
      src: string;
      altText: string;
      href: string;
    };
  };
}

// Fillable elements extend BaseElement
interface SignatureElement extends BaseElement {
  type: "Signature";
  component: {
    isDraggable: true;
    name: "Signature Element";
    options: {
      isGhost: boolean;
      showName: boolean;
      text: string;
      required: boolean;
      fieldId: string;
      src: string;
      recipient: string;
      timestamp: number | null;
      entityName: string;
    };
  };
}

interface TextFieldElement extends BaseElement {
  type: "TextField";
  component: {
    isDraggable: true;
    name: "Text Field Element";
    options: {
      isGhost: boolean;
      text: string;
      required: boolean;
      fieldId: string;
      recipient: string;
      timestamp: number | null;
      entityName: string;
      placeholder: string;
    };
  };
}
```

### Phase 2: Update Redux State

#### New State Structure
```typescript
interface ContractManagementState {
  // Keep existing UI state
  pdfBuilderDrawerOpen: boolean;
  documentDrawerOpen: boolean;
  // ... other UI state

  // REMOVE these old fields:
  // pdfBytes: Uint8Array | null;           ❌ Remove
  // canvasElements: CanvasElement[];        ❌ Remove
  // pageDimensions: { [key: number]: ... }; ❌ Remove

  // ADD new fields:
  pages: Page[];                              ✅ New
  fillableFields: FillableField[];            ✅ New (global registry)
  variables: Variable[];                      ✅ Already exists
  fontsToLoad: string[];                      ✅ New

  // Keep these:
  totalPages: number;
  currentPage: number;
  activeDocument: DocumentItem | null;
  // ... rest of state
}
```

### Phase 3: Migration Actions

#### New Actions
```typescript
// Page Management
SET_PAGES = "SET_PAGES"
ADD_PAGE = "ADD_PAGE"              // Add blank or from Firebase
DELETE_PAGE = "DELETE_PAGE"
REORDER_PAGES = "REORDER_PAGES"
UPDATE_PAGE_STYLES = "UPDATE_PAGE_STYLES"

// Element Management (now page-specific)
ADD_ELEMENT_TO_PAGE = "ADD_ELEMENT_TO_PAGE"
UPDATE_ELEMENT_IN_PAGE = "UPDATE_ELEMENT_IN_PAGE"
DELETE_ELEMENT_FROM_PAGE = "DELETE_ELEMENT_FROM_PAGE"
MOVE_ELEMENT_BETWEEN_PAGES = "MOVE_ELEMENT_BETWEEN_PAGES"

// Fillable Fields Registry
REGISTER_FILLABLE_FIELD = "REGISTER_FILLABLE_FIELD"
UNREGISTER_FILLABLE_FIELD = "UNREGISTER_FILLABLE_FIELD"

// PDF Upload (Firebase)
UPLOAD_PDF_TO_FIREBASE = "UPLOAD_PDF_TO_FIREBASE"
SET_PAGE_FIREBASE_URL = "SET_PAGE_FIREBASE_URL"
```

### Phase 4: Migration Utilities

#### Convert Old to New
```typescript
function migrateOldDocumentToGHL(oldDoc: DocumentItem): {
  pages: Page[];
  fillableFields: FillableField[];
} {
  const pages: Page[] = [];
  const fillableFields: FillableField[] = [];

  // Group elements by page
  const elementsByPage = groupBy(oldDoc.canvasElements || [], 'page');

  for (let pageNum = 1; pageNum <= totalPages; pageNum++) {
    const pageElements = elementsByPage[pageNum] || [];
    const children: (BlockElement | FillableElement)[] = [];

    // Convert each element
    for (const oldElement of pageElements) {
      const newElement = convertElementToGHL(oldElement);
      children.push(newElement);

      // Register fillable fields globally
      if (isFillableElement(newElement)) {
        fillableFields.push(extractFillableField(newElement));
      }
    }

    const page: Page = {
      type: "Page",
      version: 2,
      id: generateId(),
      children,
      component: {
        name: "Page",
        options: {
          src: "", // Will be populated after Firebase upload
          pageDimensions: {
            dimensions: oldDoc.pageDimensions[pageNum] || { width: 816, height: 1056 },
            margins: { top: 48, right: 48, bottom: 48, left: 48 },
            rotation: "portrait"
          }
        }
      },
      responsiveStyles: {
        large: {
          backgroundColor: "#ffffff",
          backgroundPosition: "top left",
          backgroundSize: "cover",
          backgroundRepeat: "repeat",
          opacity: 100
        }
      }
    };

    pages.push(page);
  }

  return { pages, fillableFields };
}

function convertElementToGHL(oldElement: CanvasElement): BlockElement | FillableElement {
  const baseElement = {
    version: 1,
    id: oldElement.id,
    children: []
  };

  // Convert based on type
  switch (oldElement.type) {
    case 'heading':
      return {
        ...baseElement,
        type: "Text",
        component: {
          name: "Text Element",
          options: {
            text: oldElement.content
          }
        },
        responsiveStyles: {
          large: {
            position: {
              top: calculateTopFromOrder(oldElement.order),
              left: 0,
              bottom: 0
            },
            padding: {
              top: "10px",
              bottom: "10px",
              left: "10px",
              right: "10px"
            },
            scale: { scaleX: 1, scaleY: 1 }
          }
        }
      };

    case 'text-field':
      return {
        ...baseElement,
        type: "TextField",
        component: {
          isDraggable: true,
          name: "Text Field Element",
          options: {
            isGhost: true,
            text: "",
            required: oldElement.required || false,
            fieldId: `text_field_${oldElement.id}`,
            recipient: "assignedContact",
            timestamp: null,
            entityName: "contacts",
            placeholder: oldElement.placeholder || "Enter value"
          }
        },
        responsiveStyles: {
          large: {
            position: {
              top: oldElement.y,
              left: oldElement.x,
              width: oldElement.width,
              height: oldElement.height,
              preferBottom: false,
              preferRight: false
            },
            dimensions: {
              width: oldElement.width,
              height: oldElement.height
            },
            padding: { top: "0px", bottom: "0px", left: "0px", right: "0px" },
            scale: { scaleX: 1, scaleY: 1 }
          }
        }
      };

    // ... other conversions
  }
}
```

---

## Implementation Steps

### Step 1: Create New Interface File
Create `contractManagement/utils/ghl-interfaces.ts` with all new types

### Step 2: Update Reducer
- Add new state fields (`pages`, `fillableFields`, `fontsToLoad`)
- Keep old fields temporarily for migration
- Add new actions

### Step 3: Create Migration Utilities
- `old-to-ghl-converter.ts` - Convert old docs to new format
- `firebase-upload-helper.ts` - Handle PDF→Firebase conversion

### Step 4: Update Components
- Modify page rendering to use `pages` array
- Update element rendering to use page.children
- Remove pdfBytes rendering logic

### Step 5: Backend Updates
- Update DocumentModel to store new structure
- Add Firebase upload endpoints
- Create migration script for existing documents

### Step 6: Testing & Cleanup
- Test all CRUD operations
- Verify page reordering
- Remove old state fields
- Clean up unused code

---

## Benefits of New Approach

✅ **No PDF Buffer**: Firebase images are lighter
✅ **Better Organization**: Page-centric hierarchy
✅ **Easier Blank Pages**: Just set `src: ""`
✅ **Simpler Reordering**: Reorder pages array
✅ **Cleaner State**: Elements nested in pages
✅ **Better Performance**: Lazy load page images
✅ **Scalability**: Easy to add/remove pages

---

## Next Steps

1. Review this plan
2. Create new type definitions
3. Implement migration utilities
4. Update reducer gradually
5. Test with sample documents
6. Deploy to production

Would you like me to start implementing any specific phase?
